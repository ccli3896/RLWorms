3+4
a = 4
a <- 4
a <- 5
a=6
getwd()
setwd("Research")
dir()
setwd("R_RamanathanLab/")
dir()
setwd("20_09_07_Repo/")
dir()
setwd("RLWorms/")
dir()
setwd("02_08_Trees/")
dir()
library(reticulate)
np <- import("numpy")
d <- np$load(fname,allow_pickle=T)
# Start by formatting for R.
# Rename columns to Cory's variables
fname = "./Data/Rand09-02-12-06/arr_for_r.npy"
d <- as_tibble(d)
d <- d %>% rename(pos_1=V1, pos2=V2, obs=V3, n=V4, which=V5)
# Start by formatting for R.
# Rename columns to Cory's variables
fname = "Data/Rand09-02-12-06/arr_for_r.npy"
np <- import("numpy")
d <- np$load(fname,allow_pickle=T)
d <- as_tibble(d)
library(tidyverse)
d <- as_tibble(d)
d <- d %>% rename(pos_1=V1, pos2=V2, obs=V3, n=V4, which=V5)
d
# SET THESE PARAMETERS
n = 12
n_dim = 2
thomps_cutoff = 0.1 # reward for sampling 'on' when true surface is within this value of 0
error_scale = 1 # rough scale of observation error (sd for specific value)
dim_regularization = 3 # higher values -> more smoothness & sparsity
bart_form = obs ~ 0 + which + . - n
m_bart = model.matrix(bart_form, data=d_bart)
d <- np$load(fname,allow_pickle=T)
d_bart <- as_tibble(d)
d_bart <- d_bart %>% rename(pos_1=V1, pos2=V2, obs=V3, n=V4, which=V5)
# PARAMETERS
n = 12
n_dim = 2
error_scale = 1 # rough scale of observation error (sd for specific value)
dim_regularization = 3 # higher values -> more smoothness & sparsity
thomps_cutoff = 0.1 # reward for sampling 'on' when true surface is within this value of 0
# Start by formatting for R.
# Rename columns to Cory's variables
fname = "Data/Rand09-02-12-06/arr_for_r.npy"
np <- import("numpy")
d <- np$load(fname,allow_pickle=T)
d_bart <- as_tibble(d)
d_bart <- d_bart %>% rename(pos_1=V1, pos2=V2, obs=V3, n=V4, which=V5)
bart_form = obs ~ 0 + which + . - n
m_bart = model.matrix(bart_form, data=d_bart)
d_bart
imp_dims = 1:n_dim
# Fit model
m = wbart(m_bart, d_bart$obs, sparse=TRUE, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.5,
w=d_bart$n)
library(BART)
# Fit model
m = wbart(m_bart, d_bart$obs, sparse=TRUE, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.5,
w=d_bart$n)
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
dim_drop = 0.01 # threshold below which we drop dimensions. lower = more conservative
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
other_locs = rep(floor(n/2), n_dim - length(new_imp_dims))
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
source("utils.R")
source("/worm-sampling/worm-sampling/utils.R")
dir()
source("./worm-sampling/worm-sampling/utils.R")
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
m_pred = model.matrix(~ 0 + which + ., data=d_pred)
preds = predict(m, m_pred)
dim(preds)
preds_diff = preds[,d_pred$which==1] - preds[,d_pred$which==0]
dim(preds_diff)
preds = t(apply(preds_diff, 2, quantile, c(0.25, 0.5, 0.75)))
dim(preds)
head(preds)
colnames(preds) = c("q25", "q50", "q75")
region_policy = apply(preds_diff, 2, function(x) mean(abs(x) <= thomps_cutoff))
d_out = bind_cols(filter(d_pred, which==1), as_tibble(preds)) %>%
mutate(policy = region_policy,
IQR = (q75 - q25),
prob = exp(-abs(q50) / IQR))
head(d_out)
dim(region_policy)
head(region_policy)
region_policy
dim(preds_diff)
head(preds_diff)
np$save(preds_diff,"R_for_arr.npy")
np$save("R_for_arr.npy", preds_diff)
error_scale = 5 # rough scale of observation error (sd for specific value)
# Fit model (BART with dirichlet prior)
m = wbart(m_bart, d_bart$obs, sparse=TRUE, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.5,
w=d_bart$n)
other_locs = rep(floor(n/2), n_dim - length(new_imp_dims))
m_pred = model.matrix(~ 0 + which + ., data=d_pred)
preds = predict(m, m_pred)
# Dropping dimensions if necessary; making predictions
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
preds_diff = preds[,d_pred$which==1] - preds[,d_pred$which==0]
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
# Save to return to Python
np$save("R_for_arr.npy",preds_diff)
# Fit model (BART with dirichlet prior)
m = wbart(m_bart, d_bart$obs, sparse=F, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.5,
w=d_bart$n)
# Dropping dimensions if necessary; making predictions
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
other_locs = rep(floor(n/2), n_dim - length(new_imp_dims))
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
m_pred = model.matrix(~ 0 + which + ., data=d_pred)
preds = predict(m, m_pred)
preds_diff = preds[,d_pred$which==1] - preds[,d_pred$which==0]
# Save to return to Python
np$save("R_for_arr.npy",preds_diff)
d
m_bart
d_bart$obs
# Fit model (BART with dirichlet prior)
m = wbart(m_bart, d_bart$obs, sparse=T, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.8,
w=d_bart$n)
other_locs = rep(floor(n/2), n_dim - length(new_imp_dims))
m_pred = model.matrix(~ 0 + which + ., data=d_pred)
preds = predict(m, m_pred)
# Dropping dimensions if necessary; making predictions
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
preds_diff = preds[,d_pred$which==1] - preds[,d_pred$which==0]
# Save to return to Python
np$save("R_for_arr.npy",preds_diff)
# Fit model (BART with dirichlet prior)
m = wbart(m_bart, d_bart$obs, sparse=T, a=0.5*(1+1/length(imp_dims)),
ntree=200, usequants=T, ndpost=800,
power=dim_regularization, sigest=error_scale, sigquant=0.8,)
# Dropping dimensions if necessary; making predictions
new_imp_dims = which(m$varprob.mean[-1] >= dim_drop)
other_locs = rep(floor(n/2), n_dim - length(new_imp_dims))
d_pred = crossing(pos = map(1:(n^length(imp_dims)), index_to_grid, n, n_dim),
which = 0:1) %>%
filter(map_lgl(pos, ~ all(.[-new_imp_dims] == other_locs))) %>%
unnest_wider(pos, names_sep="_")
m_pred = model.matrix(~ 0 + which + ., data=d_pred)
preds = predict(m, m_pred)
